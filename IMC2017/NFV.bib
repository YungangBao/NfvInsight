
@inproceedings{gember-jacobson_opennf:_2014,
	address = {New York, NY, USA},
	series = {{SIGCOMM} '14},
	title = {{OpenNF}: {Enabling} {Innovation} in {Network} {Function} {Control}},
	isbn = {978-1-4503-2836-4},
	shorttitle = {{OpenNF}},
	url = {http://doi.acm.org/10.1145/2619239.2626313},
	doi = {10.1145/2619239.2626313},
	abstract = {Network functions virtualization (NFV) together with software-defined networking (SDN) has the potential to help operators satisfy tight service level agreements, accurately monitor and manipulate network traffic, and minimize operating expenses. However, in scenarios that require packet processing to be redistributed across a collection of network function (NF) instances, simultaneously achieving all three goals requires a framework that provides efficient, coordinated control of both internal NF state and network forwarding state. To this end, we design a control plane called OpenNF. We use carefully designed APIs and a clever combination of events and forwarding updates to address race conditions, bound overhead, and accommodate a variety of NFs. Our evaluation shows that OpenNF offers efficient state control without compromising flexibility, and requires modest additions to NFs.},
	urldate = {2017-05-08},
	booktitle = {Proceedings of the 2014 {ACM} {Conference} on {SIGCOMM}},
	publisher = {ACM},
	author = {Gember-Jacobson, Aaron and Viswanathan, Raajay and Prakash, Chaithan and Grandl, Robert and Khalid, Junaid and Das, Sourav and Akella, Aditya},
	year = {2014},
	keywords = {middleboxes, network functions, software-defined networking},
	pages = {163--174}
}

@inproceedings{palkar_e2:_2015,
	address = {New York, NY, USA},
	series = {{SOSP} '15},
	title = {E2: {A} {Framework} for {NFV} {Applications}},
	isbn = {978-1-4503-3834-9},
	shorttitle = {E2},
	url = {http://doi.acm.org/10.1145/2815400.2815423},
	doi = {10.1145/2815400.2815423},
	abstract = {By moving network appliance functionality from proprietary hardware to software, Network Function Virtualization promises to bring the advantages of cloud computing to network packet processing. However, the evolution of cloud computing (particularly for data analytics) has greatly benefited from application-independent methods for scaling and placement that achieve high efficiency while relieving programmers of these burdens. NFV has no such general management solutions. In this paper, we present a scalable and application-agnostic scheduling framework for packet processing, and compare its performance to current approaches.},
	urldate = {2017-05-08},
	booktitle = {Proceedings of the 25th {Symposium} on {Operating} {Systems} {Principles}},
	publisher = {ACM},
	author = {Palkar, Shoumik and Lan, Chang and Han, Sangjin and Jang, Keon and Panda, Aurojit and Ratnasamy, Sylvia and Rizzo, Luigi and Shenker, Scott},
	year = {2015},
	pages = {121--136}
}

@inproceedings{bremler-barr_openbox:_2016,
	address = {New York, NY, USA},
	series = {{SIGCOMM} '16},
	title = {{OpenBox}: {A} {Software}-{Defined} {Framework} for {Developing}, {Deploying}, and {Managing} {Network} {Functions}},
	isbn = {978-1-4503-4193-6},
	shorttitle = {{OpenBox}},
	url = {http://doi.acm.org/10.1145/2934872.2934875},
	doi = {10.1145/2934872.2934875},
	abstract = {We present OpenBox — a software-defined framework for network-wide development, deployment, and management of network functions (NFs). OpenBox effectively decouples the control plane of NFs from their data plane, similarly to SDN solutions that only address the network’s forwarding plane. OpenBox consists of three logic components. First, user-defined OpenBox applications provide NF specifications through the OpenBox north-bound API. Second, a logically-centralized OpenBox controller is able to merge logic of multiple NFs, possibly from multiple tenants, and to use a network-wide view to efficiently deploy and scale NFs across the network data plane. Finally, OpenBox instances constitute OpenBox’s data plane and are implemented either purely in software or contain specific hardware accelerators (e.g., a TCAM). In practice, different NFs carry out similar processing steps on the same packet, and our experiments indeed show a significant improvement of the network performance when using OpenBox. Moreover, OpenBox readily supports smart NF placement, NF scaling, and multi-tenancy through its controller.},
	urldate = {2017-05-08},
	booktitle = {Proceedings of the 2016 {ACM} {SIGCOMM} {Conference}},
	publisher = {ACM},
	author = {Bremler-Barr, Anat and Harchol, Yotam and Hay, David},
	year = {2016},
	keywords = {middleboxes, network functions, Software-Defined Networks},
	pages = {511--524}
}

@inproceedings{sherry_making_2012,
	address = {New York, NY, USA},
	series = {{SIGCOMM} '12},
	title = {Making {Middleboxes} {Someone} else's {Problem}: {Network} {Processing} {As} a {Cloud} {Service}},
	isbn = {978-1-4503-1419-0},
	shorttitle = {Making {Middleboxes} {Someone} else's {Problem}},
	url = {http://doi.acm.org/10.1145/2342356.2342359},
	doi = {10.1145/2342356.2342359},
	abstract = {Modern enterprises almost ubiquitously deploy middlebox processing services to improve security and performance in their networks. Despite this, we find that today's middlebox infrastructure is expensive, complex to manage, and creates new failure modes for the networks that use them. Given the promise of cloud computing to decrease costs, ease management, and provide elasticity and fault-tolerance, we argue that middlebox processing can benefit from outsourcing the cloud. Arriving at a feasible implementation, however, is challenging due to the need to achieve functional equivalence with traditional middlebox deployments without sacrificing performance or increasing network complexity. In this paper, we motivate, design, and implement APLOMB, a practical service for outsourcing enterprise middlebox processing to the cloud. Our discussion of APLOMB is data-driven, guided by a survey of 57 enterprise networks, the first large-scale academic study of middlebox deployment. We show that APLOMB solves real problems faced by network administrators, can outsource over 90\% of middlebox hardware in a typical large enterprise network, and, in a case study of a real enterprise, imposes an average latency penalty of 1.1ms and median bandwidth inflation of 3.8\%.},
	urldate = {2017-05-08},
	booktitle = {Proceedings of the {ACM} {SIGCOMM} 2012 {Conference} on {Applications}, {Technologies}, {Architectures}, and {Protocols} for {Computer} {Communication}},
	publisher = {ACM},
	author = {Sherry, Justine and Hasan, Shaddi and Scott, Colin and Krishnamurthy, Arvind and Ratnasamy, Sylvia and Sekar, Vyas},
	year = {2012},
	keywords = {Cloud, middlebox, outsourcing},
	pages = {13--24}
}

@inproceedings{sherry_rollback-recovery_2015,
	address = {New York, NY, USA},
	series = {{SIGCOMM} '15},
	title = {Rollback-{Recovery} for {Middleboxes}},
	isbn = {978-1-4503-3542-3},
	url = {http://doi.acm.org/10.1145/2785956.2787501},
	doi = {10.1145/2785956.2787501},
	abstract = {Network middleboxes must offer high availability, with automatic failover when a device fails. Achieving high availability is challenging because failover must correctly restore lost state (e.g., activity logs, port mappings) but must do so quickly (e.g., in less than typical transport timeout values to minimize disruption to applications) and with little overhead to failure-free operation (e.g., additional per-packet latencies of 10-100s of us). No existing middlebox design provides failover that is correct, fast to recover, and imposes little increased latency on failure-free operations. We present a new design for fault-tolerance in middleboxes that achieves these three goals. Our system, FTMB (for Fault-Tolerant MiddleBox), adopts the classical approach of "rollback recovery" in which a system uses information logged during normal operation to correctly reconstruct state after a failure. However, traditional rollback recovery cannot maintain high throughput given the frequent output rate of middleboxes. Hence, we design a novel solution to record middlebox state which relies on two mechanisms: (1) 'ordered logging', which provides lightweight logging of the information needed after recovery, and (2) a `parallel release' algorithm which, when coupled with ordered logging, ensures that recovery is always correct. We implement ordered logging and parallel release in Click and show that for our test applications our design adds only 30\${\textbackslash}mu\$s of latency to median per packet latencies. Our system introduces moderate throughput overheads (5-30\%) and can reconstruct lost state in 40-275ms for practical systems.},
	urldate = {2017-05-08},
	booktitle = {Proceedings of the 2015 {ACM} {Conference} on {Special} {Interest} {Group} on {Data} {Communication}},
	publisher = {ACM},
	author = {Sherry, Justine and Gao, Peter Xiang and Basu, Soumya and Panda, Aurojit and Krishnamurthy, Arvind and Maciocco, Christian and Manesh, Maziar and Martins, João and Ratnasamy, Sylvia and Rizzo, Luigi and Shenker, Scott},
	year = {2015},
	keywords = {middlebox reliability, parallel fault-tolerance},
	pages = {227--240}
}
